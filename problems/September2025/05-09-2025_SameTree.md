# Same Tree (LeetCode)
Link: https://leetcode.com/problems/same-tree/description/

Solution - 
## Recursive Approach
- **Time Complexity**: O(n)
- **Space Complexity**: O(h)
```C++
bool isSameTree(TreeNode* p, TreeNode* q) {
    if(!p && !q) return true;
    if(!p || !q) return false;
    if(p -> val != q -> val) return false;
    return isSameTree(p -> left, q -> left) 
    && isSameTree(p -> right, q -> right); 
}
```

## Iterative Approach using Queue
- **Time Complexity**: O(n)
- **Space Complexity**: O(n)
```C++
bool isSameTree(TreeNode* p, TreeNode* q) {
    queue<pair<TreeNode*, TreeNode*>> nodeQueue;
    nodeQueue.push({p, q});
    
    while (!nodeQueue.empty()) {
        auto [node1, node2] = nodeQueue.front();
        nodeQueue.pop();
        if (!node1 && !node2) continue;
        if (!node1 || !node2 || node1->val != node2->val) return false;
        nodeQueue.push({node1->left, node2->left});
        nodeQueue.push({node1->right, node2->right});
    }
    
    return true; 
}
```
## Iterative Approach using Stack
- **Time Complexity**: O(n)
- **Space Complexity**: O(h)
```C++
bool isSameTree(TreeNode* p, TreeNode* q) {
    stack<pair<TreeNode*, TreeNode*>> nodeStack;
    nodeStack.push({p, q});
    
    while (!nodeStack.empty()) {
        auto [node1, node2] = nodeStack.top();
        nodeStack.pop();
        if (!node1 && !node2) continue;
        if (!node1 || !node2 || node1->val != node2->val) return false;
        nodeStack.push({node1->left, node2->left});
        nodeStack.push({node1->right, node2->right});
    }
    
    return true; 
}
```
